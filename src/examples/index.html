<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Re:Frame</title>
  <style>
    html, body, #container {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
<div id="container"></div>

<!-- Shaders -->
<script id="vss" type="x-shader/x-vertex">
  // @formatter:off
  // support logarithmic depth buffer
  #ifdef USE_LOGDEPTHBUF
    #ifdef USE_LOGDEPTHBUF_EXT
      varying float vFragDepth;
      varying float vIsPerspective;
    #else
      uniform float logDepthBufFC;
    #endif
  #endif
  #define EPSILON 1e-6

  // define ambient light constants.
  const highp vec3 AMBIENT_INTENSITY = vec3(0.5);
  const highp vec3 AMBIENT_COLOR = vec3(0.5);
  const highp vec3 AMBIENT_DIRECTION = vec3(0.85, 0.8, 0.75);

  varying highp vec3 vPosition;
  varying highp vec3 vLighting;

  bool isPerspectiveMatrix(mat4 m) {
    return m[2][3] == - 1.0;
  }

  void main() {

    // projection.
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    // handle logarithmic depth buffer
    #ifdef USE_LOGDEPTHBUF
      #ifdef USE_LOGDEPTHBUF_EXT
        vFragDepth = 1.0 + gl_Position.w;
        vIsPerspective = float(isPerspectiveMatrix(projectionMatrix));
      #else
        if (isPerspectiveMatrix(projectionMatrix)) {
          gl_Position.z = log2(max(EPSILON, gl_Position.w + 1.0)) * logDepthBufFC - 1.0;
          gl_Position.z *= gl_Position.w;
        }
      #endif
    #endif

    // calculate vertex position.
    vPosition = position;

    // calculate ambient light.
    highp float direction = max(dot(normalMatrix * normal, AMBIENT_DIRECTION), 0.0);
    vLighting = AMBIENT_INTENSITY + (AMBIENT_COLOR * direction);
  }
  // @formatter:on
</script>
<script id="fss" type="x-shader/x-fragment">
  // @formatter:off
  // support logarithmic depth buffer
  #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
    uniform float logDepthBufFC;
    varying float vFragDepth;
    varying float vIsPerspective;
  #endif

  uniform vec4 uSamplingPoints[MAX_SAMPLING_POINT_COUNT];
  uniform sampler2D tColorMap;

  varying highp vec3 vPosition;
  varying highp vec3 vLighting;

  void main() {

    // handle logarithmic depth buffer
    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
      gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2(vFragDepth) * logDepthBufFC * 0.5;
    #endif

    // calculate weight.
    float weight = 0.0;
    for (int i = 0; i < MAX_SAMPLING_POINT_COUNT; i ++) {
      highp float intensity = uSamplingPoints[i].w;
      highp float distance = distance(vPosition, uSamplingPoints[i].xyz);
      weight = max(weight, max(intensity - distance, 0.0));
    }

    // fill color
    gl_FragColor = vec4(texture2D(tColorMap, vec2(weight, weight)).xyz * vLighting, 1.0);
  }
</script>

<!-- GameEngine -->
<script type="importmap">
{
  "imports": {
    "three": "../../node_modules/three/build/three.module.js",
    "OrbitControls": "../../node_modules/three/examples/jsm/controls/OrbitControls.js",
    "Lut": "../../node_modules/three/examples/jsm/math/Lut.js",
    "reframe": "../../src/reframe/index.js"
  }
}









</script>
<script type="module" src="index.js"></script>

<!-- Initialize spector debugger. -->
<script src="../../node_modules/spectorjs/dist/spector.bundle.js"></script>
<script>
  const spector = new SPECTOR.Spector();
  spector.displayUI();
</script>
</body>
</html>